#Options
GenerateScanner = true
GenerateParser = true
Language = Java
ScannerName = Lexico
ParserName = Sintatico
SemanticName = Semantico
ScannerCaseSensitive = true
ScannerTable = Full
Input = String
Parser = SLR
#RegularDefinitions
d:[0-9]
l:[a-zA-Z]
w:[\ \t\n\s\r]
#Tokens
: {w}+

// ENTRADA E SAÍDA
KEY_PRINT: "print"
KEY_READ: "read"

// PRIMITIVOS
KEY_VARIABLE: {l}({l}|{d}|"_")*
KEY_DECIMAL: {d}+\.{d}+
KEY_INTEGER: {d}+
KEY_BINARY: "0b"[01]+
KEY_HEXADECIMAL: "0x"[0-9a-fA-F]+
KEY_STRING: \"([^\"\\]|\\.|[\n\r])*\"

// PALAVRAS RESERVADAS
KEY_TYPE_INT = KEY_VARIABLE:"int"
KEY_TYPE_FLOAT = KEY_VARIABLE:"float"
KEY_TYPE_STRING = KEY_VARIABLE:"string"
KEY_TYPE_BOOLEAN = KEY_VARIABLE:"bool"
KEY_TYPE_FUNC = KEY_VARIABLE:"func"
KEY_TYPE_VOID = KEY_VARIABLE:"void"
KEY_IF = KEY_VARIABLE:"if"
KEY_ELSE = KEY_VARIABLE:"else"
KEY_ELIF = KEY_VARIABLE:"elif"
KEY_DO = KEY_VARIABLE:"do"
KEY_WHILE = KEY_VARIABLE:"while"
KEY_FOR = KEY_VARIABLE:"for"
KEY_RETURN = KEY_VARIABLE:"return"
KEY_FUNCTION = KEY_VARIABLE:"function"
KEY_CONST = KEY_VARIABLE:"const"
KEY_VAR = KEY_VARIABLE:"var"
KEY_SWITCH = KEY_VARIABLE:"switch"
KEY_CASE = KEY_VARIABLE:"case"
KEY_BREAK = KEY_VARIABLE:"break"
KEY_DEFAULT = KEY_VARIABLE:"default"
KEY_THROW = KEY_VARIABLE:"throw"
KEY_CONTINUE = KEY_VARIABLE:"continue"
KEY_TRUE = KEY_VARIABLE:"true"
KEY_FALSE = KEY_VARIABLE:"false"
KEY_NULL = KEY_VARIABLE:"null"

// COMENTÁRIOS
KEY_COMMENT_MULT_LINE: [/][\*].*(˜ | ~|ˆ|\^|.|\n)*[\*][/]
KEY_COMMENT_LINE: ["/"]["/"][^\r\n]*
 
// OPERADORES ARITMÉTICOS
KEY_SUM: \+
KEY_SUB: \-
KEY_MULT: \*
KEY_DIV: /
KEY_MOD: "%"
KEY_EXPO: "**"
KEY_INCREMENT: "++"
KEY_DECREMENT: "--"
KEY_ATTR: =

// OPERADORES LÓGICOS
KEY_OR: "||"
KEY_AND: "&&"
KEY_NOT: "!"

// OPERADORES RELACIONAIS
KEY_GREATER: ">"
KEY_LESSER: "<"
KEY_GREATER_EQUAL: ">="
KEY_LESSER_EQUAL: "<="
KEY_EQUAL: "=="
KEY_NOT_EQUAL: "!="

// OPERADORES BIT A BIT
KEY_BIT_SR: ">>"
KEY_BIT_SL: "<<"
KEY_BIT_AND: "&"
KEY_BIT_OR: "|"
KEY_NEGACAO: "!"
KEY_BIT_XOR: \^
KEY_BIT_NOT: "~"

// DELIMITADORES E PONTUADORES
KEY_DOT: "."
KEY_COMMA: ","
KEY_SEMICOLON: ";"
KEY_COLON: ":"
KEY_LPAREN: "("
KEY_RPAREN: ")"
KEY_LBRACKET: "["
KEY_RBRACKET: "]"
KEY_LBRACE: "{"
KEY_RBRACE: "}"

#NonTerminals
<program>
<rowswritten>
<emptybracket>
<emptybrace>
<typeofvalue>
<typeoflvalue>
<deffunction>
<increment>
<arrayincrement>
<decrement>
<arraydecrement>
<whilescope>
<fortype>
<forvalue>
<forscope>
<attrstate>
<multiattrscope>
<attrarrayscope>
<attrscope>
<arrayvalues>
<arrayscope>
<elifscope>
<ifscope>
<printscope>
<readscope>
<primitivetype>
<complextype>
<type>
<param>
<params>
<attrsparams>
<function>
<while>
<dowhile>
<for>
<attrvalue>
<attrarray>
<attrarraybyindex>
<attr>
<switchcase>
<cases>
<case>
<default>
<else>
<elif>
<if>
<array>
<print>
<read>
<comments>
<return>
<break>
<continue>
<throw>
<funccall>
<functioncall>
<statement>
<single_command>
<commands>
<command>
<exp>
<exp1>
<exp2>
<exp3>
<exp4>
<exp5>
<exp6>
<exp7>
<exp8>
<exp9>
<exp10>
<exp11>
<value>
<indexedvalue>
<op_rel>
<op_neg>
<op_bitwise>
<op_arit_baixa>
<op_arit_alta>
#Grammar
// Sintaxes
<rowswritten> ::= KEY_LBRACE <commands> KEY_RBRACE;
<emptybracket> ::= KEY_LBRACKET KEY_RBRACKET;
<emptybrace> ::= KEY_LBRACE KEY_RBRACE;
<typeofvalue> ::= KEY_VARIABLE KEY_COLON <type>;
<typeoflvalue> ::= <indexedvalue> KEY_COLON <type>;

<deffunction> ::= KEY_FUNCTION KEY_VARIABLE KEY_LPAREN KEY_RPAREN KEY_COLON
  | KEY_FUNCTION KEY_VARIABLE KEY_LPAREN <params> KEY_RPAREN KEY_COLON;
  
<increment> ::= KEY_VARIABLE KEY_INCREMENT;
<arrayincrement> ::= KEY_VARIABLE KEY_LBRACKET <exp> KEY_RBRACKET KEY_INCREMENT;
<decrement> ::= KEY_VARIABLE KEY_DECREMENT;
<arraydecrement> ::= KEY_VARIABLE KEY_LBRACKET <exp> KEY_RBRACKET KEY_DECREMENT;
<whilescope> ::= KEY_WHILE KEY_LPAREN <exp> KEY_RPAREN;
<fortype> ::= KEY_TYPE_FLOAT | KEY_TYPE_INT; 
<forvalue> ::= KEY_INTEGER | KEY_DECIMAL; 
<forscope> ::= KEY_FOR KEY_LPAREN <attr> <exp> KEY_SEMICOLON <exp> KEY_RPAREN;
<attrstate> ::= KEY_CONST | KEY_VAR;
<multiattrscope> ::= KEY_VARIABLE KEY_COMMA <multiattrscope> | KEY_VARIABLE KEY_COMMA <typeofvalue>;
<attrarrayscope> ::= KEY_VARIABLE KEY_LBRACKET <exp> KEY_RBRACKET KEY_COLON <type>;
<attrscope> ::= <typeofvalue> 
  | <multiattrscope> 
  | <attrstate> <typeofvalue> 
  | <attrstate> <multiattrscope>
  | <typeoflvalue>                   
  | <attrstate> <typeoflvalue>;      

<arrayvalues> ::= <exp> KEY_COMMA <arrayvalues> | <exp>;
<arrayscope> ::= <emptybracket> | KEY_LBRACKET <arrayvalues> KEY_RBRACKET;
<elifscope> ::= KEY_ELIF KEY_LPAREN <exp> KEY_RPAREN;
<ifscope> ::= KEY_IF KEY_LPAREN <exp> KEY_RPAREN;

<printscope> ::= KEY_LPAREN <exp> KEY_RPAREN KEY_SEMICOLON;
<readscope> ::= KEY_LPAREN KEY_VARIABLE KEY_RPAREN KEY_SEMICOLON
  | KEY_LPAREN <indexedvalue> KEY_RPAREN KEY_SEMICOLON;

// Types
<primitivetype> ::= KEY_TYPE_INT | KEY_TYPE_FLOAT | KEY_TYPE_STRING | KEY_TYPE_BOOLEAN | KEY_TYPE_FUNC | KEY_TYPE_VOID;
<complextype> ::= <primitivetype> <emptybracket>;
<type> ::= <primitivetype> | <complextype>;

// Parameters
<param> ::= <typeofvalue> | <typeofvalue> KEY_COMMA <param>;
<params> ::= <param> <params> | <param>;
<attrsparams> ::= <exp> KEY_COMMA <attrsparams> | <exp>;

// Function
<function> ::= <deffunction> <type> <emptybrace> | <deffunction> <type> <rowswritten>;

// Loops
<while> ::= <whilescope> <statement>;
<dowhile> ::= KEY_DO <statement> <whilescope> KEY_SEMICOLON;
<for> ::= <forscope> <statement>; 

// Attribution
<attrvalue> ::= <exp> KEY_COMMA <attrvalue> | <exp> KEY_SEMICOLON;
<attrarray> ::= <arrayscope> KEY_COMMA <attrarray> | <array>;
<attrarraybyindex> ::= <arrayscope> KEY_LBRACKET <exp> KEY_RBRACKET KEY_COMMA <attrarraybyindex>
  | <arrayscope> KEY_LBRACKET <exp> KEY_RBRACKET KEY_SEMICOLON;

<attr> ::= <attrscope> KEY_ATTR <attrvalue>
  | <attrscope> KEY_ATTR <attrarray>
  | <attrscope> KEY_ATTR <attrarraybyindex>
  | <attrscope> KEY_SEMICOLON
  | <increment> KEY_SEMICOLON 
  | <arrayincrement> KEY_SEMICOLON 
  | <decrement> KEY_SEMICOLON
  | <arraydecrement> KEY_SEMICOLON;

// Conditionals
<switchcase> ::= KEY_SWITCH KEY_LPAREN <exp> KEY_RPAREN KEY_LBRACE <cases> KEY_RBRACE 
  | KEY_SWITCH KEY_LPAREN <exp> KEY_RPAREN KEY_LBRACE <cases> <default> KEY_RBRACE;
<cases> ::= <case> <cases> | <case>;
<case> ::= KEY_CASE <exp> KEY_COLON <commands>;
<default> ::= KEY_DEFAULT KEY_COLON <commands>;

<else> ::= KEY_ELSE <statement>;
<elif> ::= <elifscope> <statement> | <elifscope> <statement> <else>;
<if> ::= <ifscope> <statement> | <ifscope> <statement> <else> | <ifscope> <statement> <elif>;

// Array
<array> ::= <arrayscope> KEY_SEMICOLON;

// I/O
<print> ::= KEY_PRINT <printscope>;
<read> ::= KEY_READ <readscope>;

// Comments
<comments> ::= KEY_COMMENT_LINE | KEY_COMMENT_MULT_LINE;

// Finals
<return> ::= KEY_RETURN <exp> KEY_SEMICOLON
  | KEY_RETURN KEY_SEMICOLON;
<break> ::= KEY_BREAK KEY_SEMICOLON;
<continue> ::= KEY_CONTINUE KEY_SEMICOLON;
<throw> ::= KEY_THROW <exp> KEY_SEMICOLON;

// Commands
<funccall> ::= KEY_VARIABLE KEY_LPAREN KEY_RPAREN
  | KEY_VARIABLE KEY_LPAREN <attrsparams> KEY_RPAREN;

<functioncall> ::= <funccall> KEY_SEMICOLON;

<statement> ::= <rowswritten> | <single_command>;
<single_command> ::= <print> | <read> | <attr> | <return> | <break> | <continue> | <throw> | <array>;
<program> ::= <commands>;
<commands> ::= <command> <commands> | <command>;
<command> ::= <single_command> | <function> | <switchcase> | <comments> | <if> | <while> | <for> | <dowhile> | <functioncall>;
  
// Expressions
<exp>  ::= <exp> KEY_OR <exp1> | <exp1>;
<exp1> ::= <exp1> KEY_AND <exp2> | <exp2>;
<exp2> ::= <exp2> KEY_BIT_OR <exp3> | <exp3>;
<exp3> ::= <exp3> KEY_EXPO <exp4> | <exp4>;
<exp4> ::= <exp4> KEY_BIT_AND <exp5> | <exp5>;
<exp5> ::= <exp5> <op_rel> <exp6> | <exp6>;
<exp6> ::= <exp6> <op_bitwise> <exp7> | <exp7>;
<exp7> ::= <exp7> <op_arit_baixa> <exp8> | <exp8>;
<exp8> ::= <exp8> <op_arit_alta> <exp9> | <exp9> ;
<exp9> ::= <op_neg> <value> | <value>;
<exp10> ::= <increment> | <decrement>;
<exp11> ::= <arrayincrement> | <arraydecrement>;

// Values
<value> ::= KEY_VARIABLE
  | KEY_DECIMAL 
  | KEY_INTEGER 
  | KEY_BINARY 
  | KEY_HEXADECIMAL 
  | KEY_STRING 
  | KEY_TRUE 
  | KEY_FALSE 
  | KEY_NULL 
  | KEY_LPAREN <exp> KEY_RPAREN
  | <exp10>
  | <exp11>
  | <funccall>
  | <indexedvalue>;

<indexedvalue> ::= KEY_VARIABLE KEY_LBRACKET <exp> KEY_RBRACKET
  | <indexedvalue> KEY_LBRACKET <exp> KEY_RBRACKET;

// Operations
<op_rel> ::= KEY_GREATER | KEY_LESSER | KEY_EQUAL | KEY_GREATER_EQUAL | KEY_LESSER_EQUAL | KEY_ATTR | KEY_NOT_EQUAL; 
<op_neg> ::= KEY_SUB | KEY_BIT_NOT | KEY_NOT;
<op_bitwise> ::= KEY_BIT_SL | KEY_BIT_SR | KEY_BIT_XOR | KEY_BIT_NOT;
<op_arit_baixa> ::= KEY_SUM | KEY_SUB;
<op_arit_alta> ::= KEY_MULT | KEY_DIV | KEY_MOD;