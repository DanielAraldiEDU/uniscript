#Options
GenerateScanner = true
GenerateParser = true
Language = Java
ScannerName = Lexico
ParserName = Sintatico
SemanticName = Semantico
ScannerCaseSensitive = true
ScannerTable = Full
Input = String
Parser = SLR
#RegularDefinitions
d:[0-9]
l:[a-zA-Z]
w:[\ \t\n\s\r]
#Tokens
: {w}+

// ENTRADA E SAÍDA
KEY_PRINT: "print"
KEY_READ: "read"

// PRIMITIVOS
KEY_VARIABLE: {l}({l}|{d}|"_")*
KEY_DECIMAL: {d}+\.{d}+
KEY_INTEGER: {d}+
KEY_BINARY: "0b"[01]+
KEY_HEXADECIMAL: "0x"[0-9a-fA-F]+
KEY_STRING: \"([^\"\\]|\\.|[\n\r])*\"

// PALAVRAS RESERVADAS
KEY_TYPE_INT = KEY_VARIABLE:"int"
KEY_TYPE_FLOAT = KEY_VARIABLE:"float"
KEY_TYPE_STRING = KEY_VARIABLE:"string"
KEY_TYPE_BOOLEAN = KEY_VARIABLE:"bool"
KEY_TYPE_CHAR = KEY_VARIABLE:"char"
KEY_IF = KEY_VARIABLE:"if"
KEY_ELSE = KEY_VARIABLE:"else"
KEY_ELIF = KEY_VARIABLE:"elif"
KEY_DO = KEY_VARIABLE:"do"
KEY_WHILE = KEY_VARIABLE:"while"
KEY_FOR = KEY_VARIABLE:"for"
KEY_RETURN = KEY_VARIABLE:"return"
KEY_FUNCTION = KEY_VARIABLE:"function"
KEY_CONST = KEY_VARIABLE:"const"
KEY_VAR = KEY_VARIABLE:"var"
KEY_SWITCH = KEY_VARIABLE:"switch"
KEY_CASE = KEY_VARIABLE:"case"
KEY_BREAK = KEY_VARIABLE:"break"
KEY_DEFAULT = KEY_VARIABLE:"default"
KEY_TRY = KEY_VARIABLE:"try"
KEY_CATCH = KEY_VARIABLE:"catch"
KEY_FINALLY = KEY_VARIABLE:"finally"
KEY_THROW = KEY_VARIABLE:"throw"
KEY_CONTINUE = KEY_VARIABLE:"continue"
KEY_TRUE = KEY_VARIABLE:"true"
KEY_FALSE = KEY_VARIABLE:"false"
KEY_OBJECT = KEY_VARIABLE:"object"
KEY_VOID = KEY_VARIABLE:"void"

// COMENTÁRIOS
KEY_COMMENT_MULT_LINE: [/][\*].*(˜ | ~|ˆ|\^|.|\n)*[\*][/]
KEY_COMMENT_LINE: ["/"]["/"][^\r\n]*
 
// OPERADORES ARITMÉTICOS
KEY_SUM: \+
KEY_SUB: \-
KEY_MULT: \*
KEY_DIV: /
KEY_MOD: "%"
KEY_EXPO: "**"
KEY_INCREMENT: "++"
KEY_DECREMENT: "--"
KEY_ATTR: =

// OPERADORES LÓGICOS
KEY_OR: "||"
KEY_AND: "&&"
KEY_NOT: "!"

// OPERADORES RELACIONAIS
KEY_GREATER: ">"
KEY_LESSER: "<"
KEY_GREATER_EGUAL: ">="
KEY_LESSER_EGUAL: "<="
KEY_EQUAL: "=="
KEY_NOT_EQUAL: "!="

// OPERADORES BIT A BIT
KEY_BIT_SR: ">>"
KEY_BIT_SL: "<<"
KEY_BIT_AND: "&"
KEY_BIT_OR: "|"
KEY_NEGACAO: "!"
KEY_BIT_XOR: \^
KEY_BIT_NOT: "~"

// DELIMITADORES E PONTUADORES
KEY_DOT: "."
KEY_COMMA: ","
KEY_SEMICOLON: ";"
KEY_COLON: ":"
KEY_LPAREN: "("
KEY_RPAREN: ")"
KEY_LBRACKET: "["
KEY_RBRACKET: "]"
KEY_LBRACE: "{"
KEY_RBRACE: "}"

#NonTerminals
<dowhile>
<while>
<else>
<elif>
<if>
<commands>
<command>
<exp>
<exp1>
<exp2>
<exp3>
<exp4>
<exp5>
<exp6>
<exp7>
<exp8>
<exp9>
<value>
<op_rel>
<op_neg>
<op_bitwise>
<op_arit_baixa>
<op_arit_alta>
#Grammar
// TODO: 
// Entender porque quando dois ou mais bloco condicionais (if e depois outro if...) dão erro de fim de sentança.
// O mesmo está acontecendo para os loops.

// TODO: Tem que fazer o for
<while> ::= KEY_WHILE KEY_LPAREN <exp> KEY_RPAREN <commands>
  | KEY_WHILE KEY_LPAREN <exp> KEY_RPAREN KEY_LBRACE <commands> KEY_RBRACE;
<dowhile> ::= KEY_DO <commands> <while>
  | KEY_DO KEY_LBRACE <commands> KEY_RBRACE <while>;

<else> ::= KEY_ELSE <commands>
  | KEY_ELSE KEY_LBRACE <commands> KEY_RBRACE;
<elif> ::= KEY_ELIF KEY_LPAREN <exp> KEY_RPAREN <commands>
  | KEY_ELIF KEY_LPAREN <exp> KEY_RPAREN <commands> <else>
  | KEY_ELIF KEY_LPAREN <exp> KEY_RPAREN KEY_LBRACE <commands> KEY_RBRACE
  | KEY_ELIF KEY_LPAREN <exp> KEY_RPAREN KEY_LBRACE <commands> KEY_RBRACE <else>;
<if> ::= KEY_IF KEY_LPAREN <exp> KEY_RPAREN <commands>
  | KEY_IF KEY_LPAREN <exp> KEY_RPAREN <commands> <else>
  | KEY_IF KEY_LPAREN <exp> KEY_RPAREN <commands> <elif>
  | KEY_IF KEY_LPAREN <exp> KEY_RPAREN KEY_LBRACE <commands> KEY_RBRACE
  | KEY_IF KEY_LPAREN <exp> KEY_RPAREN KEY_LBRACE <commands> KEY_RBRACE <else>
  | KEY_IF KEY_LPAREN <exp> KEY_RPAREN KEY_LBRACE <commands> KEY_RBRACE <elif>;

<commands> ::= <command> <commands> | <command>;
<command> ::= KEY_PRINT KEY_LPAREN <exp> KEY_RPAREN KEY_SEMICOLON
  | KEY_READ KEY_LPAREN <exp> KEY_RPAREN KEY_SEMICOLON; // Terá que adicionar mais comandos aqui (acredito eu)
  
// Exemplo para testar tudo: -x + 8.8 - !x * 2 / ~y % 3 << 7 != y >> 3 || (x <= 3 && y > 8) | p & (h ^ g)
<exp>  ::= <exp> KEY_OR <exp1> | <exp1>;
<exp1> ::= <exp1> KEY_AND <exp2> | <exp2>;
<exp2> ::= <exp2> KEY_BIT_OR <exp3> | <exp3>;
<exp3> ::= <exp3> KEY_EXPO <exp4> | <exp4>;
<exp4> ::= <exp4> KEY_BIT_AND <exp5> | <exp5>;
<exp5> ::= <exp5> <op_rel> <exp6> | <exp6>;
<exp6> ::= <exp6> <op_bitwise> <exp7> | <exp7>;
<exp7> ::= <exp7> <op_arit_baixa> <exp8> | <exp8>;
<exp8> ::= <exp8> <op_arit_alta> <exp9> | <exp9> ;
<exp9> ::= <op_neg> <value> | <value>;

<value> ::= KEY_VARIABLE | KEY_DECIMAL | KEY_INTEGER | KEY_BINARY | KEY_HEXADECIMAL | KEY_STRING | KEY_TRUE | KEY_FALSE | KEY_LPAREN <exp> KEY_RPAREN;

<op_rel> ::= KEY_GREATER | KEY_LESSER | KEY_EQUAL | KEY_GREATER_EGUAL | KEY_LESSER_EGUAL | KEY_ATTR | KEY_NOT_EQUAL; 
<op_neg> ::= KEY_SUB | KEY_BIT_NOT | KEY_NOT;
<op_bitwise> ::= KEY_BIT_SL | KEY_BIT_SR;
<op_arit_baixa> ::= KEY_SUM | KEY_SUB;
<op_arit_alta> ::= KEY_MULT | KEY_DIV | KEY_MOD;
