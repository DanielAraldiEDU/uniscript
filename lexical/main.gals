#Options
GenerateScanner = true
GenerateParser = true
Language = Java
ScannerName = Lexico
ParserName = Sintatico
SemanticName = Semantico
ScannerCaseSensitive = true
ScannerTable = Full
Input = String
Parser = SLR
#RegularDefinitions
d:[0-9]
l:[a-zA-Z]
w:[\ \t\n\s\r]
#Tokens
: {w}+

// ENTRADA E SAÍDA
KEY_PRINT: "print"
KEY_READ: "read"

// PRIMITIVOS
KEY_VARIABLE: {l}({l}|{d}|"_")*
KEY_DECIMAL: {d}+\.{d}+
KEY_INTEGER: {d}+
KEY_BINARY: "0b"[01]+
KEY_HEXADECIMAL: "0x"[0-9a-fA-F]+
KEY_STRING: \"([^\"\\]|\\.|[\n\r])*\"

// PALAVRAS RESERVADAS
KEY_TYPE_INT = KEY_VARIABLE:"int"
KEY_TYPE_FLOAT = KEY_VARIABLE:"float"
KEY_TYPE_STRING = KEY_VARIABLE:"string"
KEY_TYPE_BOOLEAN = KEY_VARIABLE:"bool"
KEY_TYPE_FUNC = KEY_VARIABLE:"func"
KEY_TYPE_OBJECT = KEY_VARIABLE:"object"
KEY_TYPE_VOID = KEY_VARIABLE:"void"
KEY_IF = KEY_VARIABLE:"if"
KEY_ELSE = KEY_VARIABLE:"else"
KEY_ELIF = KEY_VARIABLE:"elif"
KEY_DO = KEY_VARIABLE:"do"
KEY_WHILE = KEY_VARIABLE:"while"
KEY_FOR = KEY_VARIABLE:"for"
KEY_RETURN = KEY_VARIABLE:"return"
KEY_FUNCTION = KEY_VARIABLE:"function"
KEY_CONST = KEY_VARIABLE:"const"
KEY_VAR = KEY_VARIABLE:"var"
KEY_SWITCH = KEY_VARIABLE:"switch"
KEY_CASE = KEY_VARIABLE:"case"
KEY_BREAK = KEY_VARIABLE:"break"
KEY_DEFAULT = KEY_VARIABLE:"default"
KEY_TRY = KEY_VARIABLE:"try"
KEY_CATCH = KEY_VARIABLE:"catch"
KEY_FINALLY = KEY_VARIABLE:"finally"
KEY_THROW = KEY_VARIABLE:"throw"
KEY_CONTINUE = KEY_VARIABLE:"continue"
KEY_TRUE = KEY_VARIABLE:"true"
KEY_FALSE = KEY_VARIABLE:"false"

// COMENTÁRIOS
KEY_COMMENT_MULT_LINE: [/][\*].*(˜ | ~|ˆ|\^|.|\n)*[\*][/]
KEY_COMMENT_LINE: ["/"]["/"][^\r\n]*
 
// OPERADORES ARITMÉTICOS
KEY_SUM: \+
KEY_SUB: \-
KEY_MULT: \*
KEY_DIV: /
KEY_MOD: "%"
KEY_EXPO: "**"
KEY_INCREMENT: "++"
KEY_DECREMENT: "--"
KEY_ATTR: =

// OPERADORES LÓGICOS
KEY_OR: "||"
KEY_AND: "&&"
KEY_NOT: "!"

// OPERADORES RELACIONAIS
KEY_GREATER: ">"
KEY_LESSER: "<"
KEY_GREATER_EGUAL: ">="
KEY_LESSER_EGUAL: "<="
KEY_EQUAL: "=="
KEY_NOT_EQUAL: "!="

// OPERADORES BIT A BIT
KEY_BIT_SR: ">>"
KEY_BIT_SL: "<<"
KEY_BIT_AND: "&"
KEY_BIT_OR: "|"
KEY_NEGACAO: "!"
KEY_BIT_XOR: \^
KEY_BIT_NOT: "~"

// DELIMITADORES E PONTUADORES
KEY_DOT: "."
KEY_COMMA: ","
KEY_SEMICOLON: ";"
KEY_COLON: ":"
KEY_LPAREN: "("
KEY_RPAREN: ")"
KEY_LBRACKET: "["
KEY_RBRACKET: "]"
KEY_LBRACE: "{"
KEY_RBRACE: "}"

#NonTerminals
<attr>
<primitivetype>
<complextype>
<type>
<param>
<params>
<function>
<while>
<dowhile>
<fortype>
<forvalue>
<for>
<state>
<else>
<elif>
<if>
<commands>
<command>
<exp>
<exp1>
<exp2>
<exp3>
<exp4>
<exp5>
<exp6>
<exp7>
<exp8>
<exp9>
<exp10>
<value>
<op_rel>
<op_neg>
<op_bitwise>
<op_arit_baixa>
<op_arit_alta>
#Grammar
// TODO: 
// Entender porque quando dois ou mais bloco condicionais (if e depois outro if...) dão erro de fim de sentança.
// O mesmo está acontecendo para os loops.
// O mesmo está acontecendo para as funções.

<primitivetype> ::= KEY_TYPE_INT | KEY_TYPE_FLOAT | KEY_TYPE_STRING | KEY_TYPE_BOOLEAN | KEY_TYPE_FUNC | KEY_TYPE_VOID;
<complextype> ::= <primitivetype> KEY_LBRACKET KEY_RBRACKET;
<type> ::= <primitivetype> | <complextype>;
<param> ::= KEY_VARIABLE KEY_COLON <type>
  | KEY_VARIABLE KEY_COLON <type> KEY_COMMA <param>;
<params> ::= <param> <params> | <param>;
<function> ::= KEY_FUNCTION KEY_VARIABLE KEY_LPAREN KEY_RPAREN KEY_COLON <type> KEY_LBRACE KEY_RBRACE
  | KEY_FUNCTION KEY_VARIABLE KEY_LPAREN KEY_RPAREN KEY_COLON <type> KEY_LBRACE <commands> KEY_RBRACE
  | KEY_FUNCTION KEY_VARIABLE KEY_LPAREN <params> KEY_RPAREN KEY_COLON <type> KEY_LBRACE <commands> KEY_RBRACE
  | KEY_FUNCTION KEY_VARIABLE KEY_LPAREN <params> KEY_RPAREN KEY_COLON <type> KEY_LBRACE KEY_RBRACE;

// TODO: Tem que fazer o for
<while> ::= KEY_WHILE KEY_LPAREN <exp> KEY_RPAREN <commands>
  | KEY_WHILE KEY_LPAREN <exp> KEY_RPAREN KEY_LBRACE <commands> KEY_RBRACE;
<dowhile> ::= KEY_DO <commands> <while>
  | KEY_DO KEY_LBRACE <commands> KEY_RBRACE <while>;
<fortype> ::= KEY_TYPE_FLOAT | KEY_TYPE_INT; 
<forvalue> ::= KEY_INTEGER | KEY_DECIMAL; 
<for> ::= KEY_FOR KEY_LPAREN <attr> <exp> KEY_SEMICOLON <exp> KEY_RPAREN <commands> 
  | KEY_FOR KEY_LPAREN <attr> <exp> KEY_SEMICOLON <exp> KEY_RPAREN KEY_LBRACE <commands> KEY_RBRACE; 

<state> ::= KEY_CONST | KEY_VAR;
<attr> ::= <state> KEY_VARIABLE KEY_COLON <type> KEY_ATTR <exp> KEY_SEMICOLON
  | <state> KEY_VARIABLE KEY_COLON <type> KEY_ATTR <function>;

<else> ::= KEY_ELSE <commands>
  | KEY_ELSE KEY_LBRACE KEY_RBRACE
  | KEY_ELSE KEY_LBRACE <commands> KEY_RBRACE;
<elif> ::= KEY_ELIF KEY_LPAREN <exp> KEY_RPAREN <commands>
  | KEY_ELIF KEY_LPAREN <exp> KEY_RPAREN <commands> <else>
  | KEY_ELIF KEY_LPAREN <exp> KEY_RPAREN KEY_LBRACE KEY_RBRACE
  | KEY_ELIF KEY_LPAREN <exp> KEY_RPAREN KEY_LBRACE <commands> KEY_RBRACE
  | KEY_ELIF KEY_LPAREN <exp> KEY_RPAREN KEY_LBRACE KEY_RBRACE <else>
  | KEY_ELIF KEY_LPAREN <exp> KEY_RPAREN KEY_LBRACE <commands> KEY_RBRACE <else>;
<if> ::= KEY_IF KEY_LPAREN <exp> KEY_RPAREN <commands>
  | KEY_IF KEY_LPAREN <exp> KEY_RPAREN <commands> <else>
  | KEY_IF KEY_LPAREN <exp> KEY_RPAREN <commands> <elif>
  | KEY_IF KEY_LPAREN <exp> KEY_RPAREN KEY_LBRACE KEY_RBRACE
  | KEY_IF KEY_LPAREN <exp> KEY_RPAREN KEY_LBRACE <commands> KEY_RBRACE
  | KEY_IF KEY_LPAREN <exp> KEY_RPAREN KEY_LBRACE KEY_RBRACE <else>
  | KEY_IF KEY_LPAREN <exp> KEY_RPAREN KEY_LBRACE <commands> KEY_RBRACE <else>
  | KEY_IF KEY_LPAREN <exp> KEY_RPAREN KEY_LBRACE KEY_RBRACE <elif>
  | KEY_IF KEY_LPAREN <exp> KEY_RPAREN KEY_LBRACE <commands> KEY_RBRACE <elif>;

<commands> ::= <command> <commands> | <command>;
<command> ::= KEY_PRINT KEY_LPAREN <exp> KEY_RPAREN KEY_SEMICOLON
  | KEY_READ KEY_LPAREN <exp> KEY_RPAREN KEY_SEMICOLON; // Terá que adicionar mais comandos aqui (acredito eu)
  
<exp>  ::= <exp> KEY_OR <exp1> | <exp1>;
<exp1> ::= <exp1> KEY_AND <exp2> | <exp2>;
<exp2> ::= <exp2> KEY_BIT_OR <exp3> | <exp3>;
<exp3> ::= <exp3> KEY_EXPO <exp4> | <exp4>;
<exp4> ::= <exp4> KEY_BIT_AND <exp5> | <exp5>;
<exp5> ::= <exp5> <op_rel> <exp6> | <exp6>;
<exp6> ::= <exp6> <op_bitwise> <exp7> | <exp7>;
<exp7> ::= <exp7> <op_arit_baixa> <exp8> | <exp8>;
<exp8> ::= <exp8> <op_arit_alta> <exp9> | <exp9> ;
<exp9> ::= <op_neg> <value> | <value> | <exp10>;
<exp10> ::= KEY_VARIABLE KEY_INCREMENT | KEY_VARIABLE KEY_DECREMENT;

<value> ::= KEY_VARIABLE | KEY_DECIMAL | KEY_INTEGER | KEY_BINARY | KEY_HEXADECIMAL | KEY_STRING | KEY_TRUE | KEY_FALSE | KEY_LPAREN <exp> KEY_RPAREN;

<op_rel> ::= KEY_GREATER | KEY_LESSER | KEY_EQUAL | KEY_GREATER_EGUAL | KEY_LESSER_EGUAL | KEY_ATTR | KEY_NOT_EQUAL; 
<op_neg> ::= KEY_SUB | KEY_BIT_NOT | KEY_NOT;
<op_bitwise> ::= KEY_BIT_SL | KEY_BIT_SR;
<op_arit_baixa> ::= KEY_SUM | KEY_SUB;
<op_arit_alta> ::= KEY_MULT | KEY_DIV | KEY_MOD;
